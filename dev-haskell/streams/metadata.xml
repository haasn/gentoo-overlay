<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<herd>haskell</herd>
	<maintainer>
		<email>haskell@gentoo.org</email>
	</maintainer>
	<longdescription>
		Various Haskell 2010 stream comonads.
		* &quot;Data.Stream.Future&quot; provides a coinductive anti-causal stream, or non-empty &#39;ZipList&#39;. The comonad provides access to only the
		tail of the stream. Like a conventional &#39;ZipList&#39;, this is /not/ a monad.
		
		&gt; data Future a = Last a | a :&lt; Future a
		
		* &quot;Data.Stream.Future.Skew&quot; provides a non-empty skew-binary random-access-list with the semantics of @Data.Stream.Future@. As with
		&quot;Data.Stream.Future&quot; this stream is not a &#39;Monad&#39;, since the &#39;Applicative&#39; instance zips streams of potentially differing lengths.
		The random-access-list structure provides a number of operations logarithmic access time, but makes &#39;Data.Stream.Future.Skew.cons&#39;
		less productive. Where applicable &quot;Data.Stream.Infinite.Skew&quot; may be more efficient, due to a lazier and more efficient &#39;Applicative&#39;
		instance.
		
		&gt;
		
		* &quot;Data.Stream.Infinite&quot; provides a coinductive infinite anti-causal stream. The &#39;Comonad&#39; provides access to the tail of the
		stream and the &#39;Applicative&#39; zips streams together. Unlike &#39;Future&#39;, infinite stream form a &#39;Monad&#39;. The monad diagonalizes
		the &#39;Stream&#39;, which is consistent with the behavior of the &#39;Applicative&#39;, and the view of a &#39;Stream&#39; as a isomorphic to the reader
		monad from the natural numbers. Being infinite in length, there is no &#39;Alternative&#39; instance, but instead the &#39;FunctorAlt&#39;
		instance provides access to the &#39;Semigroup&#39; of interleaving streams.
		
		&gt; data Stream a = a :&lt; Stream a
		
		* &quot;Data.Stream.Infinite.Skew&quot; provides an infinite skew-binary random-access-list with the semantics of &quot;Data.Stream.Infinite&quot;
		Since every stream is infinite, the &#39;Applicative&#39; instance can be considerably less strict than the corresponding instance for
		&quot;Data.Stream.Future.Skew&quot; and performs asymptotically better.
		
		&gt;
		
		* &quot;Data.Stream.Infinite.Functional.Zipper&quot; provides a bi-infinite sequence, represented as a pure function with an accumulating
		parameter added to optimize moving the current focus.
		
		&gt; data Zipper a = !Integer :~ (Integer -&gt; a)
		
		* &quot;Data.Stream.Supply&quot; provides a comonadic supply of unique values, which are
		generated impurely as the tree is explored.
		
		/Changes since 0.6.3/:
		
		* &quot;Data.Stream.NonEmpty&quot; renamed to &quot;Data.List.NonEmpty&quot; and pushed upstream into the semigroups package.
		
		/Changes since 0.5.1/:
		
		* Removed a redundant UNPACK pragma
		
		/Changes since 0.5/:
		
		* Data.Stream.Supply added
		
		/Changes since 0.1/:
		
		* A number of strictness issues with &#39;NonEmpty&#39; were fixed
		
		* More documentation
	</longdescription>
</pkgmetadata>
